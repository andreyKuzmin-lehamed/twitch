# Выжимка знаний по теме Типов в Golang

## Базовые встроенные типы

### Часто используемые

  - bool - логический тип;
  - int - целочисленный числово тип;
  - float64 - с плавающей точкой;
  - string - строковый тип;

### Редко используемые

  - Целочисленные - uint, int8, uint8, int16, uint16, int32, uint32, int64, uint64, int, uint, и uintptr;
  - С плавающей точкой - float32;
  - Сложные числовые - complex64и complex128;

### int vs uint

  Если тип начинается с u, тогда он строго положительный. 
  Например, int8 - это с -128 до 127, а вот unit8 это с 0 до 255.
  При этом, диапазон значений, сохраняется, и зависит от числа в окончании типа:
 
  - uint8	unsigned 8-bit integer	(0 to 255)
  - uint16	unsigned 16-bit integer	(0 to 65535)
  - uint32	unsigned 32-bit integer	(0 to 4294967295)
  - uint64	unsigned 64-bit integer	(0 to 18446744073709551615)
  - int8	signed 8-bit integer	(-128 to 127)
  - int16	signed 16-bit integer	(-32768 to 32767)
  - int32	signed 32-bit integer	(-2147483648 to 2147483647)
  - int64	signed 64-bit integer	(-9223372036854775808 to 9223372036854775807)

### Размер типов

  Значение занимает в памяти, всегда фиксированное количество места, столько, сколько занимает тип.
  Вне зависимости, от того, какое конкретно значение у переменной с данным типом.

  int и uint, они либо 32 либо 64 (либо еще что) в зависимости от разрядности ОС среды выполнения
  
### Байты vs Биты в названиях типа

  В названии типа, указаны биты, делим на 8 - получаем байты. (int32 - 32 бита - 4 байта)

### uintptr - зачем?

  uintptr - может указывать на uint, и тогда он тоже самое, что *uint.
  Но, он может указывать, вообще на любой тип данных, просто сам указатель, представлен как целочисленное представление адреса памяти. 
  То есть, сам указатель является положительным целочисленным числом, и поэтому он UINTptr, но указывает, он на что угодно поэтому он uintPTR

  Ещё, вычитал, что это необходимый полу-костыль, для работы c С-вызываемым кодом. Он как бы указатель, но как бы и целый тип

### КомплЕксный тип данных

  Нужен, для хранения действительного + мнимого числа. Если complex64, то это float32+float32, а если complex128, то это float64+float64.

  Да, я тоже до конца не понял, что такое комплЕксное число (Мне сказали, что главное помнить, что это вектор на плоскости)