# Выжимка знаний по теме Типов в Golang

## Базовые встроенные типы

### Часто используемые

  - bool - логический тип;
  - int - целочисленный числовой тип;
  - float64 - с плавающей точкой;
  - string - строковый тип;
  - byte - числовой тип для обозначения байтов символа;
  - rune - числовой тип для обозначения символа;

### Редко используемые

  - Целочисленные - uint, int8, uint8, int16, uint16, int32, uint32, int64, uint64, int, uint, и uintptr;
  - С плавающей точкой - float32;
  - Сложные числовые - complex64 и complex128;

### Значения по умолчанию

  Нулевые значения такие:
   - Логическое - false;
   - Числовое - 0 (целые) и 0.0 (с запятой)
   - Строковое - ""

## Строковые типы

### rune vs byte

  - byte - это, получается, как символ записывается в байтах. Проблема тут в том, что некоторые символы записываются несколькими байтами, или один символ может быть записан разными наборами байтов. И при переборе строки как слайса байтов, можно получить больше итераций чем символов в строке и можно получить кракозябры из таких "сложных" символов.

  - rune - это, получается, тоже, то как символ записывается каким-то уникальным значением, и тоже там что-то с юникодом связано. Но, руна это просто число, которое уникально для каждого символа. И поэтому, перебирать лучше строку, как слайс рун, а не байтов. В этом случае, всегда произойдет ожидаемое количество итераций, и не будет кракозябр.

### Обратные кавычки vs двойных

  Строковые литералы могут быть с двойными кавычками или с обратными кавычками.

  Разница в том, что с обратными кавычками - это тоже самое что, необработанная строка, в которой видны только буквальные символы. 
  То есть, там может быть какой-то символ табуляции или переноса строки и их не будет видно, как их не видно в обычном тексте.

  А вот в двойных кавычках, все они будут видны, как экранированные символы. 

### Посимвольный перебор строки

  *Строка, это на самом деле просто slice с byte, но только для чтения.* 

  - Если читать напрямую, через string\[i\] тогда, получим byte, с русскими символами это вызывает проблемы, они кракозябрятся
  - Если читать через for pos, el := range string {}, то в el будет rune, и руна нормально отрабатывает с русскими символами

  По строке, получается, безопаснее перебираться через range. 
  Тогда количество итераций будет равно количеству символов в строке.
  Либо, переводить из []byte в []rune и тогда можно и обычным for, для перевода нужно написать []rune(тут_слайс_байтов)

  Перебор через range ещё и оптимизированней, это не просто сахар.

## Числовые типы

### uint vs int

  Если тип начинается с u, тогда он строго положительный. 
  Например, int8 - это с -128 до 127, а вот unit8 это с 0 до 255.
  При этом, диапазон значений, сохраняется, и зависит от числа в окончании типа:
 
  - uint8	unsigned 8-bit integer	(0 to 255)
  - uint16	unsigned 16-bit integer	(0 to 65535)
  - uint32	unsigned 32-bit integer	(0 to 4294967295)
  - uint64	unsigned 64-bit integer	(0 to 18446744073709551615)
  - int8	signed 8-bit integer	(-128 to 127)
  - int16	signed 16-bit integer	(-32768 to 32767)
  - int32	signed 32-bit integer	(-2147483648 to 2147483647)
  - int64	signed 64-bit integer	(-9223372036854775808 to 9223372036854775807)

### uintptr

  uintptr - может указывать на uint, и тогда он тоже самое, что *uint.
  Но, он может указывать, вообще на любой тип данных, просто сам указатель, представлен как целочисленное представление адреса памяти. 
  То есть, сам указатель является положительным целочисленным числом, и поэтому он UINTptr, но указывает, он на что угодно поэтому он uintPTR

  Ещё, вычитал, что это необходимый полу-костыль, для работы c С-вызываемым кодом. Он как бы указатель, но как бы и целый тип

### Размер типов

  В названии типа, указаны биты, делим на 8 - получаем байты. (int32 - 32 бита - 4 байта)

  Значение занимает в памяти, всегда фиксированное количество места, столько, сколько занимает тип.
  Вне зависимости, от того, какое конкретно значение у переменной с данным типом.

  int и uint, они либо 32 либо 64 (либо еще что) в зависимости от разрядности ОС среды выполнения

### КомплЕксный тип

  Нужен, для хранения действительного + мнимого числа. Если complex64, то это float32+float32, а если complex128, то это float64+float64.

  Да, я тоже до конца не понял, что такое комплЕксное число (Мне сказали, что главное помнить, что это вектор на плоскости)

### Целочисленные литералы

  Целочисленные литералы, могут быть для десятичной, шестнадцатеричной, восьмиричной и двойчной систем:

  Литерал числа 15:

    15 // Десятичная (starts without a "0")

    0xF // Шестнадцатеричная (starts with a "0x" or "0X")
    0XF

    017 // Восьмиричная (starts with a "0", "0o" or "0O")
    0o17
    0O17

    0b1111 // Двоичная (starts with a "0b" or "0B")
    0B1111


  Литералы одного числа в разных системах равны:

    println(15 == 017) // true
    println(15 == 0xF) // true

### Литералы с плавающей точкой

  Литералы числа с плавающей точкой, могут записываться, со следующими нюансами:

  - Ноль в начале, или нули - игнорируются. Более того, ноль перед точкой можно не писать;
  - Ноль после точки, тоже можно не писать. Точка в этом случае нужна, чтобы было понятно, что это тип не целого числа;
  - Есть буковка E или маленька e - это одно и тоже. Если после Е идет + (или нет знака вообще) тогда число, которое написано перед Е, умножается на 10 в степени того числа которое написано после E (ну или после плюса, если он есть). А если после Е идёт минус, то тоже самое, только число перед Е делится, а не умножается, на 10 в степени числа после минуса;

  Примеры: 

    1.23
    01.23 // == 1.23
    .23
    1.
    // An "e" or "E" starts the exponent part (10-based).
    1.23e2  // == 123.0
    123E2   // == 12300.0
    123.E+2 // == 12300.0
    1e-1    // == 0.1
    .1e0    // == 0.1
    0010e-2 // == 0.1
    0e+5    // == 0.0

  - Можно ещё объявлять так же и в шестнадцатеричной системе, только тогдо нужно E заменить на P. Там есть при этом свои приколюхи;

  Вот так можно:

    0x1p-2     // == 1.0/4 = 0.25
    0x2.p10    // == 2.0 * 1024 == 2048.0
    0x1.Fp+0   // == 1+15.0/16 == 1.9375
    0X.8p1     // == 8.0/16 * 2 == 1.0
    0X1FFFP-16 // == 0.1249847412109375

  Вот так нельзя:

    0x.p1    // мантиса (что это?) не содержит числа
    1p-2     // p экспонента (что это?) требует шестнадцатеричной мантисы (нет, правда, что это?)
    0x1.5e-2 // шестнадцатеричная мантиса (вы издеваетесь?) требует p экспаненту (экспанента, это буковка, панимаю)

  А так можно, но на самом деле это просто выражение, а не литерал:

    0x15e-2 // == 0x15e - 2 // это просто выражение

  Есть ещё мнимые, там буковка i, но это знать уже перебор для моей мозги.

### Нижнее подчеркивание

  В числах можно использовать нижнее подчеркивание для повышения читаемости.

  - С нижнего подчеркивания нельзя начинать и им нельзя заканчивать литерал;

  Вот пример для разморочки:

    // Допустимо:
    6_9          // == 69
    0_33_77_22   // == 0337722
    0x_Bad_Face  // == 0xBadFace
    0X_1F_FFP-16 // == 0X1FFFP-16
    0b1011_0111 + 0xA_B.Fp2i

    // Недопустимо:
    _69        // _ не может быть вначале
    69_        // _ не может быть вконце
    6__9       // не может быть двух подряд
    0_xBadFace // "x" не может быть после _
    1_.5       // "." точка не может быть после _
    1._5       // "." точка не может быть перед _

## Логические типы

### Литералы vs константы

  false и true пишутся с маленькой буквы: true и false - не являются литералами, в прямом смысле. Это именно константы в которых лежат литералы. 

    const STRUCT StructType = StructType{key: value, key2: value} - это литерал присваеваемый в константу

    STRUCT - это просто константа, с литералом. (Вот так же false и true)

  А что там в false и true внутри, да кто его знает.