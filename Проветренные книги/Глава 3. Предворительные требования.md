# Предварительные условия

  При небрежно выполненной предварительной подготовке проекта, ты в лучшем случае сможешь свести вред к минимуму.

  При ошибках в предварительной подготовке к разработке ПО, иногда, приходится выполнять конструирование программы дважды, трижды, а то и больше раз. Учитывая, что конструирование является самым дорогим этапом разработки, то цена ошибки, в таком случае, является очень высокой.

# Важность выполнения предварительных условий

  Качество программиста зависит от того, насколько качественно он подходит к разработке в начале, середине и в окончании проекта.

  Предварительные условия, являются началом проекта, и в отличии от тестирования, которое является окончанием проекта, предварительные условия способны обнаружить такие ошибки как "построение не того приложения" или "построение того приложения, но не тем способом".

  К примеру, если вы спроектировали "понтиак", то сколько ты его не тестируй, он не станет "роллс-ройсом". Ты даже можешь создать самый лучший "понтиак" в мире, но если тебе нужен был "роллс-ройс", то это плохой результат. 

  А если ты и создашь из "понтиака" "роллс-ройс", то это явно потребует намного больше ресурсов, чем изначальное создание "роллс-ройса".

  Предварительные условия необходимы для оценки сложности проекта перед началом этапа конструирования.

# Главная цель подготовки

  Главной целью подготовки является снижение рисков при разработке приложения.

  Предварительные условия могут на ранней стадии проекта обнаружить ошибки в выработке требований и плохое планирование проекта.

  Не смотря на то, что при подготовке можно легко допустить ошибки и тем самым принести больше проблем чем пользы, предварительные условия, при успешном их выполнении, делают разработку ПО намного эффективнее.

# Причины отсутствия подготовки

  Часто, разработчики не имеют достаточного опыта для умения правильно выполнять предварительные условия.

  В этом случае, призывать их больше времени уделять подготовке - бессмысленно, а то и вредно. Потому, что больше времени потраченного на некачественную подготовку - это просто больше потраченного в пустую времени.

  Опаснее, что разработчик не имеющий навыка правильной подготовки, начнет специально плохо выполнять подготовку, чтобы "доказать", что это ненужный этап.

  Другой случай, когда разработчик пренебрегает подготовкой из-за того, что хочет поскорее перейти к конструированию программы. 

  В этом случае, у разработчика явно недостаток опыта в решении проблем в крупных проектах, связанных с недостаточной подготовкой.

  Наконец, менеджер \ руководитель может отрицать необходимость выполнения предварительных условий, мотивируя это целями бизнеса или просто, не осознавая рисков.

  Что делать в случае, если менеджер \ руководитель настаивает на начале проекта с конструирования:

  - Ты можешь отвергнуть неэффективную методику разработки прямым текстом, конечно, если у тебя нормальные отношения с начальником и в порядке банковские счета;
  - Ты можешь притвориться, что работаешь над кодом, открыть какие-нибудь исходники, а в это время заниматься архитектурой и планированием. Да, это подход через обман, но так, ты экономишь время разработки и начальник остается доволен;
  - Ты можешь посвятить начальника в нюансы рисков невыполнения предварительных условий, чем повысишь процент грамотных, в этом вопросе, руководителей. Но, опять же, это сработает не с каждым начальником;
  - Ты можешь уволиться, да, на рынке всегда ждут хороших специалистов и жизнь слишком коротка, чтобы работать с мудаками.

# Необходимость подготовки человеческим языком

  **Обращение к логике**

  Подготовка к любому делу необходима, и её размер зависит от конкретной задачи. Например, подготовка с управленческой точки зрения - это определение сроков, формирование команды и создание технических условий, вроде количества компьютеров и т.д. 

  С технической точки зрения, так же необходима подготовка, получение представления о создаваемой системе, которое позволит не истратить лишних ресурсов на её создание. Часто, сбор требований не является простой задачей, так как бизнес не до конца знает какие проблемы он хочет решить, либо у бизнеса есть несколько точек зрения на этот вопрос, либо что-то ещё в таком духе. 

  Но даже в таком случае, хоть это и дорого, но тратить время на окончательное формирование представления о создаваемой системе, всё равно, дешевле, чем создать не ту систему, выбросить её и делать заново. 

  **Обращение к аналогии**

  Используй метафоры, ценность которых мы обсудили в прошлой главе. 

  Объясни, что возведение дома без чертежей - бессмысленное в лучшем, и очень рискованное в худшем случае занятие.

  Да, строителям посёлка не нужно знать о каждом сантиметре в каждом будущем доме до возведения самого первого дома, но если не будет изучен участок, если не будут проложены коммуникации, то возможно, канализацию придется проводить в уже построенные дома.

  **Обращение к данным**

  В книге приведены данные за последние 25 лет (к моменту написания книги) в которых делается вывод о том, что стоимость ошибки возрастает многократно в прямой зависимость от того, насколько долго она находилась в проекте. 

  К примеру, что исправление ошибки к началу конструирования обходится в 10 - 100 раз дешевле, чем её устранение в момент тестирования приложения.

  Тем ни менее, большинство проектов, всё ещё исправляют эти ошибки в последний момент, скорее всего, из-за требований бизнеса, что с одной стороны логично, а с другой стороны, не является самым оптимальным решением.

# Разные подходы к разным типам ПО

  В книге присутствует таблица с тремя столбцами: "Бизнес-системы", "Системы целевого назначения" и "Встроенные системы, от которых зависит жизнь людей". 

  При этом значения в этих столбцах достаточно путанно изложены и часто пересекаются, ниже я сформулирую основные мысли таблицы.

  - Чем серьезнее влияние ПО на человеческую жизнь, тем строже требования предъявляемые к:
     - Исполнению предварительных условий;
     - Отсутствию итеративных подходов;
     - Контролю за регистрацией кода продукта;
     - Контролю за тестированием продукта;
     - Точности внедрения продукта.
  - Для бизнес-систем лучше подходят итеративные подходы, так как их гибкость больше подходит для разработки продуктов с постоянно изменяемыми требованиями;
  - Для систем от которых зависит жизнь людей, необходим последовательный подход с тщательной проработкой каждого этапа разработки, для обеспечения высочайшей надежности системы.

# Затраты на итеративные и последовательные подходы

  Итеративный подход не уменьшает объем необходимых к выполнению предварительных условий.

  В книге показаны две таблицы, сравнения затрат на итеративный и последовательный подходы, при выполнении предварительных условий и при невыполнении предварительных условий.

  - При невыполнении предварительных условий, стоимость последовательной разработки превышает стоимость итеративной примерно на 12,5%;
  - При выполнении предварительных условий, стоимость последовательной разработки превышает стоимость итеративной примерно на столько же, но общая сумма выходит меньше.

  Из этого можно сделать вывод, что применять итеративный подход дешевле.
  
  Ошибки находятся раньше, а значит стоит их исправление дешевле. Так же, затраты на исправление ошибок появляются в конце каждой итерации, небольшими суммами, а не одной большой суммой в конце разработки.

  И где гарантия, что при последовательном подходе после исправления не будет новых ошибок?

# Выбор между итеративным и последовательным подходами

  В книге, автор приходит к выводу, что не бывает полностью итеративных или полностью последовательных проектов, и приводит следующее правило:

  - Заблаговременно определи около 80% требований и выдели время, на более позднее определение остальных требований;
  - Определи только 20% самых важных требований, а остальные определяй по мере разработки, при том, что саму разработку производи небольшими фрагментами.

  Логично, что необходимость того или иного подхода зависит от типа проекта, автор приводит несколько ситуаций когда более последовательный подход будет уместен:

  - Требования довольно стабильны;
  - Проект приложения прост и относительно понятен;
  - Группа разработчиков знакома с прикладной областью;
  - Проект не связан с особым риском;
  - Важна долговременная предсказуемость проекта;
  - Затраты на изменение требований, проекта приложения и кода скорее всего окажутся высокими;
  
  А при следующих условиях, более итеративный подход будет уместнее:

  - Требования относительно непонятны или вам кажется, что они могут оказаться нестабильными по другим причинам;
  - Проект приложения сложен, не совсем ясен или и то и другое;
  - Группа разработчиков незнакома с прикладной областью;
  - Проект сопряжен с высоким риском;
  - Долговременная предсказуемость проекта не играет особой роли;
  - Затраты на изменение требований, проекта приложения и кода скорее всего будут низкими;

  Важно понимать, что чрезмерное внимание к выполнению предварительных условий в проектах, не требующих этого, так же опасны и ведут к провалу проекта, как и недостаточное внимание к выполнению предварительных условий в проектах, требующих этого.


# Подробнее о предварительных условиях

  **Определение проблемы**

    *Прежде чем стрелять, убедитесь в том, что знаете куда целитесь*

  - Проблему нужно формулировать от лица того, кто с ней сталкивается и на его языке;
  - Проблема должна звучать как проблема, а не как решение этой проблемы;
  - Не все проблемы необходимо решать разработкой ПО;
  - Не имея хорошей формулировки проблемы, можно потратить усилия на решение не той проблемы.

  **Выработка требований**

  - Сформулированные требования предоставляют возможность создать программу которая нужна бизнесу, а не которая нужна бизнесу по мнению программиста;
  - Требования нужно формулировать от лица того, кто будет пользоваться программой;
  - Изменения в требованиях (или выяснение их отличия от представляемых программистом) на этапе проектирования архитектуры обходится в трое дороже, чем на этапе их формирования. На этапе кодирования уже в 5 - 10 раз дороже, на этапе тестирования в 10 раз, а после выпуска программы в 10 - 100 раз;
  - Коэффициенты затрат могут быть не такими страшными в небольших проектах, но тратить лишние ресурсы - это не самый адекватный подход.

  Стабильных требований не бывает.

  В идеальной ситуации:

  - Бизнес утверждает требования и больше их не меняет никогда;
  - Мы планомерно и предсказуемо разрабатываем продукт;
  - ???
  - PROFIT!

  Но на самом деле, как и программист лучше понимает проект проработав с ним какое-то время, так и бизнес лучше понимает свои требования в процессе разработки продукта.

  И игнорировать лучшее понимание требований, глупейшее занятие для бизнеса.

  Так же, важно помнить, что требования к ПО у бизнеса могут поменяться из-за каких-то внешних изменений рынка, каких-то новых нюансов области этого бизнеса и т.д.

  IBM провели исследования в которых показали, что в среднем требования изменяются на 25%, на что приходится 70-85% объема повторной работы над типичным проектом.

  По этой причине, полностью последовательный подход возможен только в "вакууме"


  **Изменение требований во время конструирования программы**

  Контрольный список: требования.

  - Специфические функциональные требования:
    - Определены ли все способы ввода данных в систему с указанием источника, точности, диапазона значений и частоты ввода?
    - Определены ли все способы вывода данных системой с указанием назначения, точности, диапазона значений, частоты и формата?
    - Определены ли все форматы вывода для Web-страниц, отчетов и т.д.?
    - Определены ли все внешние аппаратные и программные интерфейсы?
    - Определены ли все внешние коммуникационные интерфейсы с указанием протоколов установления соединения, проверки ошибок и коммуникации?
    - Определены ли все задачи, в выполнении которых нуждается пользователь?
    - Определены ли данные, используемые в каждой задаче, и данные, являющиеся результатом выполнения каждой задачи?
  
  - Специфические нефункциональные требования (требования к качеству):
    - Определено ли ожидаемое пользователем время реакции для всех необходимых операций?
    - Определены ли другие временные параметры, такие как время обработки данных, скорость их передачи и пропускная способность системы?
    - Определен ли уровень защищенности системы?
    - Определена ли надежность системы, в том числе такие аспекты, как следствия сбоев в ее работе, информация, которая должна быть защищена от сбоев, и стратегия обнаружения и исправления ошибок?
    - Определены ли минимальные требования программы к объему памяти и свободного дискового пространства?
    - Определены ли аспекты удобства сопровождения системы, в том числе способность системы адаптироваться к изменениям специфических функций, ОС и интерфейсов с другими приложениями?
    - Включено ли в требования определение успеха? Или неудачи?

  - Качество требований:
    - Написаны ли требования на языке, понятном пользователям? Согласны ли с этим пользователи?
    - Нет ли конфликтов между требованиями?
    - Определено ли приемлемое равновесие между параметрами-антагонистами, такими как устойчивость к нарушению исходных предпосылок и корректность?
    - Не присутствуют ли в требованиях элементы проектирования?
    - Согласован ли уровень детальности требований? Следует ли какое-нибудь требование определить подробнее? Менее подробно?
    - Достаточно ли ясны и понятны требования, чтобы их можно было передать независимой группе конструирования? Согласны ли с этим разработчики?
    - Каждое ли требование релевантно для проблемы и ее решения? Можно ли проследить каждое требование до его источника в проблемной среде?
    - Можно ли протестировать каждое требование? Можно ли будет провести независимое тестирование, которое позволит сказать, выполнены ли все требования?
    - Определены ли все возможные изменения требований и вероятность каждого изменения?

  - Полнота требований:
    - Указаны ли недостающие требования, которые невозможно определить до начала разработки?
    - Полны ли требования в том смысле, что если приложение будет удовлетворять всем требованиям, то оно будет приемлемо?
    - Не вызывают ли какие-нибудь требования у вас дискомфорта? Исключили ли вы требования, которые не поддаются реализации и были включены лишь для успокоения клиента или начальника?

  **Процесс проверки изменяющихся требований в процессе конструирования программы**

  - Оценить качество требований с помощью контрольного списка, если они не соответствуют списку. Остановись, исправь их и только потом продолжайте разработку;
  - Убедись, что всем известна цена изменения требований, так как бизнес может хотеть какой-то функционал, не совсем соизмеряя его пользу с той ценой, которая стоит за его внедрением посреди процесса конструирования;
  - Задай процедуру контроля изменений, чтобы бизнес не закидывал изменения каждую удобную минуту, и при этом, чтобы видел, что на рассмотрение его идей отведено отдельное время и ты понимаешь, что новые требования, хоть и усложняют разработку, но необходимы;
  - Используй такие подходы к разработке, которые легко подвергаются изменениям. Разрабатывай небольшими фрагментами, которые может "пощупать" бизнес;
  - Если предыдущие пункты невозможны, то останови работу над проектом, оставь его, а если это невозможно, то подумай, в какой ситуации ты бы его все-таки оставил и проанализируй, чем эта ситуация отличалась бы от текущей;
  - Помни про бизнес-модель проекта, все изменения должны работать на неё, а не эмоциональные желания кого-либо.

**Архитектура ПО**

  Архитектура - это общее описание системы, что-то вроде чертежа дома, подробность которого зависит от необходимостей проекта.

  Иногда, архитектуру разделяют с высокоуровневым проектом, в этом случае, архитектурой считают общее описание системы, а высокоуровневым проектом - уже описание подсистем и классов, не обязательно, в масштабе всей системы.

  Архитектура напрямую влияет на итоговое качество системы.

  Прямая задача архитектуры, предоставить руководство к конструированию ПО, уровень детальности которого соответствует их навыкам и выполняемой работе.

  Архитектура, позволяет разделить работу на части и передать конструирование назависимым друг от друга группам.

  *Хорошая Архитектура облегчает конструирование. Плохая архитектура делает его почти невозможным.*

  Не имея хорошей архитектуры, вы можете решать правильную проблему, но придти к неправильному решению.

  Цена исправления ошибок архитектуры, на последующих этапах, сопоставима с ценой исправления ошибок в требованиях.

**Задачи архитектуры**

  - Дать общее описание системы *Что мы вообще хотим сделать?*
  - Дать причины выбора именно такого решения. *Почему мы хотим сделать это именно так?*
  - Дать описание основных компонентов, то есть, описать каким методом/классом будет решено каждое из требований к ПО. Если классов/методов для решения требования больше одного, то важно, чтобы они не конфликтовали. *Из каких частей мы соберем мозайку?*
  - Дать описание ответственности компонентов, и куда у них будет доступ. *Насколько независимыми будут эти части?*
  - Дать описание, как компоненты будут взаимодействовать друг с другом. *Как эти части будут соединяться?*